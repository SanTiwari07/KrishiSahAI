"""
PDF Generation Service for KrishiSahAI
Generates professional PDF reports for Chat and Roadmap
"""

import io
import os
from datetime import datetime
from typing import List, Dict, Any
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle, Image
from reportlab.lib import colors
from reportlab.pdfgen import canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
import firebase_admin
from firebase_admin import credentials, firestore
import re
import xml.sax.saxutils as saxutils

# Initialize Firebase Admin if not already initialized
if not firebase_admin._apps:
    # This will be initialized in app.py, but we check here for safety
    pass

def get_firestore_client():
    """Get Firestore client"""
    return firestore.client()

# Register a font that supports the Rupee symbol (₹)
# Using DejaVuSans from matplotlib if available, or fallback to an absolute path if necessary
try:
    # Try to find DejaVuSans in site-packages
    import matplotlib
    mpl_data_path = matplotlib.get_data_path()
    font_path = os.path.join(mpl_data_path, 'fonts', 'ttf', 'DejaVuSans.ttf')
    
    if os.path.exists(font_path):
        pdfmetrics.registerFont(TTFont('DejaVuSans', font_path))
        pdfmetrics.registerFont(TTFont('DejaVuSans-Bold', os.path.join(mpl_data_path, 'fonts', 'ttf', 'DejaVuSans-Bold.ttf')))
        FONT_NAME = 'DejaVuSans'
        FONT_NAME_BOLD = 'DejaVuSans-Bold'
        print(f"[PDF_SERVICE] Successfully registered DejaVuSans font from {font_path}")
    else:
        # Fallback to reportlab fonts or standard fonts
        FONT_NAME = 'Helvetica'
        FONT_NAME_BOLD = 'Helvetica-Bold'
        print(f"[PDF_SERVICE] Warning: DejaVuSans.ttf not found at {font_path}, falling back to Helvetica")
except Exception as e:
    print(f"[PDF_SERVICE] Error registering font: {e}")
    FONT_NAME = 'Helvetica'
    FONT_NAME_BOLD = 'Helvetica-Bold'

# --- Shared Utilities ---

def create_pdf_header(canvas_obj, doc):
    """Create PDF header with KrishiSahAI branding"""
    canvas_obj.saveState()
    
    # Header background
    canvas_obj.setFillColor(colors.HexColor('#2D5F4F'))
    canvas_obj.rect(0, letter[1] - 1.2*inch, letter[0], 1.2*inch, fill=True, stroke=False)
    
    # Title
    canvas_obj.setFillColor(colors.white)
    canvas_obj.setFont(FONT_NAME_BOLD, 24)
    canvas_obj.drawString(0.75*inch, letter[1] - 0.7*inch, 'KrishiSahAI')
    
    canvas_obj.setFont(FONT_NAME, 14)
    canvas_obj.drawString(0.75*inch, letter[1] - 0.95*inch, 'AI Advisory Report')
    
    # Date
    canvas_obj.setFont(FONT_NAME, 10)
    date_str = datetime.now().strftime('%d %B %Y')
    canvas_obj.drawRightString(letter[0] - 0.75*inch, letter[1] - 0.85*inch, date_str)
    
    canvas_obj.restoreState()

def create_pdf_footer(canvas_obj, doc):
    """Create PDF footer"""
    canvas_obj.saveState()
    
    # Footer line
    canvas_obj.setStrokeColor(colors.HexColor('#E6E6E6'))
    canvas_obj.setLineWidth(0.5)
    canvas_obj.line(0.75*inch, 0.75*inch, letter[0] - 0.75*inch, 0.75*inch)
    
    # Footer text
    canvas_obj.setFillColor(colors.HexColor('#555555'))
    canvas_obj.setFont('Helvetica', 9)
    canvas_obj.drawString(0.75*inch, 0.5*inch, 'Generated by KrishiSahAI')
    
    # Page number
    page_num = canvas_obj.getPageNumber()
    canvas_obj.drawRightString(letter[0] - 0.75*inch, 0.5*inch, f'Page {page_num}')
    
    canvas_obj.restoreState()

def format_markdown_to_pdf_content(text: str) -> List[str]:
    """
    Convert markdown text to PDF-friendly paragraphs
    Returns list of formatted text chunks with style indicators
    """
    if not text:
        return []

    lines = text.split('\n')
    formatted_content = []
    
    for line in lines:
        line = line.strip()
        if not line:
            formatted_content.append(('spacer', ''))
            continue
        
        # Escape XML special characters
        line = saxutils.escape(line)
        
        # Convert markdown bold **text** to <b>text</b>
        # We do this before checking headers so headers can have bold too if needed (though usually headers are bold by style)
        line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
        
        # Headers
        if line.startswith('### '):
            formatted_content.append(('h3', line[4:]))
        elif line.startswith('## '):
            formatted_content.append(('h2', line[3:]))
        elif line.startswith('# '):
            formatted_content.append(('h1', line[2:]))
        # Bullet points
        elif line.startswith('- ') or line.startswith('* '):
            formatted_content.append(('bullet', line[2:]))
        # Numbered lists
        elif re.match(r'^\d+\.\s', line):
            formatted_content.append(('numbered', line))
        else:
            formatted_content.append(('normal', line))
    
    return formatted_content

def get_common_styles():
    styles = getSampleStyleSheet()
    
    return {
        'title': ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            textColor=colors.HexColor('#2D5F4F'),
            spaceAfter=12,
            alignment=TA_LEFT,
            fontName=FONT_NAME_BOLD
        ),
        'h1': ParagraphStyle(
            'CustomH1',
            parent=styles['Heading1'],
            fontSize=16,
            textColor=colors.HexColor('#2D5F4F'),
            spaceAfter=10,
            spaceBefore=14,
            fontName=FONT_NAME_BOLD
        ),
        'h2': ParagraphStyle(
            'CustomH2',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=colors.HexColor('#2D5F4F'),
            spaceAfter=8,
            spaceBefore=12,
            fontName=FONT_NAME_BOLD
        ),
        'h3': ParagraphStyle(
            'CustomH3',
            parent=styles['Heading3'],
            fontSize=12,
            textColor=colors.HexColor('#2D5F4F'),
            spaceAfter=6,
            spaceBefore=10,
            fontName=FONT_NAME_BOLD
        ),
        'normal': ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.HexColor('#1E1E1E'),
            spaceAfter=6,
            leading=14,
            fontName=FONT_NAME
        ),
        'bullet': ParagraphStyle(
            'CustomBullet',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.HexColor('#1E1E1E'),
            leftIndent=20,
            bulletIndent=10,
            spaceAfter=4,
            leading=14,
            fontName=FONT_NAME
        ),
        'table_header': ParagraphStyle(
            'TableHeader',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.white,
            alignment=TA_CENTER,
            fontName=FONT_NAME_BOLD
        ),
         'table_cell': ParagraphStyle(
            'TableCell',
            parent=styles['Normal'],
            fontSize=10,
            textColor=colors.black,
            alignment=TA_LEFT,
            leading=12,
            fontName=FONT_NAME
        ),
        'disclaimer': ParagraphStyle(
            'Disclaimer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.HexColor('#666666'),
            alignment=TA_CENTER,
            spaceBefore=20,
            fontName=FONT_NAME
        )
    }

# --- Chat PDF Generation ---

def fetch_chat_messages(user_id: str, chat_id: str) -> tuple:
    """
    Fetch chat messages from Firestore
    Returns: (chat_title, messages_list)
    """
    db = get_firestore_client()
    
    # Get chat metadata
    chat_ref = db.collection('users').document(user_id).collection('chats').document(chat_id)
    chat_doc = chat_ref.get()
    
    if not chat_doc.exists:
        raise ValueError(f"Chat {chat_id} not found")
    
    chat_data = chat_doc.to_dict()
    chat_title = chat_data.get('title', 'AI Advisory Report')
    
    # Get messages
    messages_ref = chat_ref.collection('messages')
    messages_query = messages_ref.order_by('createdAt').stream()
    
    messages = []
    for msg_doc in messages_query:
        msg_data = msg_doc.to_dict()
        messages.append({
            'role': msg_data.get('role', 'user'),
            'content': msg_data.get('content', ''),
            'timestamp': msg_data.get('createdAt')
        })
    
    return chat_title, messages

def generate_chat_pdf(user_id: str, chat_id: str) -> io.BytesIO:
    """
    Generate PDF from chat conversation
    Returns: BytesIO buffer containing the PDF
    """
    print(f"[PDF_SERVICE] generate_chat_pdf called for User: {user_id}, Chat: {chat_id}")
    try:
        chat_title, messages = fetch_chat_messages(user_id, chat_id)
    except Exception as e:
        print(f"[PDF_SERVICE] Error fetching messages: {e}")
        raise e
    
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(
        buffer,
        pagesize=letter,
        rightMargin=0.75*inch,
        leftMargin=0.75*inch,
        topMargin=1.5*inch,
        bottomMargin=1*inch
    )
    
    styles = get_common_styles()
    story = []
    
    # Chat title
    story.append(Paragraph(chat_title, styles['title']))
    story.append(Spacer(1, 0.3*inch))
    
    # Messages
    for idx, msg in enumerate(messages):
        role = msg['role']
        content = msg['content']
        
        if role == 'user':
            story.append(Paragraph(f'<b>Question:</b>', styles['h3']))
            story.append(Paragraph(content, styles['normal']))
            story.append(Spacer(1, 0.1*inch))
            
        elif role in ['assistant', 'model']:
            story.append(Paragraph(f'<b>AI Response:</b>', styles['h3']))
            
            formatted_content = format_markdown_to_pdf_content(content)
            
            for content_type, text in formatted_content:
                if content_type == 'spacer':
                    story.append(Spacer(1, 0.05*inch))
                elif content_type == 'h1':
                    story.append(Paragraph(text, styles['h1']))
                elif content_type == 'h2':
                    story.append(Paragraph(text, styles['h2']))
                elif content_type == 'h3':
                    story.append(Paragraph(text, styles['h3']))
                elif content_type == 'bullet':
                     # simple bullet for now
                    story.append(Paragraph(f'• {text}', styles['bullet']))
                elif content_type == 'numbered':
                    story.append(Paragraph(text, styles['bullet']))
                else: 
                    story.append(Paragraph(text, styles['normal']))
            
            story.append(Spacer(1, 0.3*inch))
            
            # Separator
            if idx < len(messages) - 1:
                story.append(Spacer(1, 0.1*inch))
                story.append(Paragraph('_' * 60, styles['normal'])) # visible separator
                story.append(Spacer(1, 0.2*inch))
    
    doc.build(story, onFirstPage=create_pdf_header, onLaterPages=create_pdf_header,
              canvasmaker=lambda *args, **kwargs: canvas.Canvas(*args, **kwargs))
    
    buffer.seek(0)
    return buffer


# --- Roadmap PDF Generation ---

def generate_roadmap_pdf(roadmap_data: Dict[str, Any], business_name: str) -> io.BytesIO:
    """
    Generate PDF for Roadmap data
    """
    print(f"[PDF_SERVICE] generate_roadmap_pdf for {business_name}")
    
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(
        buffer,
        pagesize=letter,
        rightMargin=0.75*inch,
        leftMargin=0.75*inch,
        topMargin=1.5*inch,
        bottomMargin=1*inch
    )
    
    styles = get_common_styles()
    story = []
    
    # Title
    title = roadmap_data.get('title', f'Roadmap for {business_name}')
    story.append(Paragraph(title, styles['title']))
    
    # Overview
    overview = roadmap_data.get('overview', '')
    if overview:
        story.append(Paragraph("Executive Summary", styles['h2']))
        for chunk in format_markdown_to_pdf_content(overview):
             if chunk[0] == 'normal':
                 story.append(Paragraph(chunk[1], styles['normal']))
    
    story.append(Spacer(1, 0.2*inch))

    # 1. Timeline (Years)
    years = roadmap_data.get('years', [])
    if years:
        story.append(Paragraph("1. Strategic Timeline (10-Year Plan)", styles['h1']))
        
        for year in years:
            # Year Header
            year_num = year.get('year', 'Year X')
            goal = year.get('goal', '')
            profit = year.get('profit', 'N/A')
            
            # Box-like style for each year
            story.append(Paragraph(f"<b>{year_num}: {goal}</b>", styles['h2']))
            
            # Content table for alignment
            # Focus
            if year.get('focus'):
                focus_text = year.get('focus')
                story.append(Paragraph(f"<b>Strategic Focus:</b> {focus_text}", styles['normal']))
                story.append(Spacer(1, 0.05*inch))
            
            # Actions
            actions = year.get('actions', [])
            if actions:
                story.append(Paragraph("<b>Key Actions:</b>", styles['normal']))
                for action in actions:
                    action_text = action
                    story.append(Paragraph(f"• {action_text}", styles['bullet']))
            
            # Profit
            story.append(Spacer(1, 0.05*inch))
            story.append(Paragraph(f"<b>Expected Profit:</b> <font color='#1B5E20'>{profit}</font>", styles['normal']))
            
            story.append(Spacer(1, 0.2*inch))
            story.append(Paragraph("-" * 80, styles['disclaimer'])) # Divider
            story.append(Spacer(1, 0.2*inch))

    # 2. Key Analysis Sections
    sections = [
        ("2. Labor & Aging Analysis", roadmap_data.get('labor_analysis')),
        ("3. Sustainability & Succession", roadmap_data.get('sustainability_plan')),
        ("4. Financial Resilience", roadmap_data.get('resilience_strategy')),
        ("5. Strategic Verdict", roadmap_data.get('verdict'))
    ]

    for title, content in sections:
        if content:
            story.append(Paragraph(title, styles['h1']))
            # Process markdown content
            for c_type, text in format_markdown_to_pdf_content(content):
                if c_type == 'bullet':
                     story.append(Paragraph(f"• {text}", styles['bullet']))
                elif c_type == 'h3':
                     story.append(Paragraph(text, styles['h3']))
                else:
                     story.append(Paragraph(text, styles['normal']))
            story.append(Spacer(1, 0.2*inch))

    # Disclaimer
    disclaimer_text = roadmap_data.get('disclaimer')
    if not disclaimer_text:
        disclaimer_text = "This roadmap is an AI-generated simulation based on provided data and regional averages. Actual results may vary due to market fluctuations, climate conditions, and individual management. This should not be considered financial or legal advice. Consult with local agricultural experts before major investments."
    
    story.append(Spacer(1, 0.5*inch))
    story.append(Paragraph(f"<b>DISCLAIMER:</b> {disclaimer_text}", styles['disclaimer']))
    
    doc.build(story, onFirstPage=create_pdf_header, onLaterPages=create_pdf_header,
              canvasmaker=lambda *args, **kwargs: canvas.Canvas(*args, **kwargs))
    
    buffer.seek(0)
    return buffer
